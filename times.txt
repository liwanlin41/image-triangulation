Averages per call

6/23: pixDoubleInt 556ms; pixEnergyInt 550ms; pixLineInt 276ms; Pixel::intersectionArea 1.8ms which is the bulk of integration process

6/24: intersecting all four sides of pixel with a segment takes 600us but intersecting all pixels takes 120ms; just creating the segments for intersection takes only 12us for all pixels though
Significant speed increase: change segment intersection detection to avoid using Matrix class (which required dynamic allocation):
New averages pixDoubleInt 83ms, pixEnergyInt 82ms, pixLineInt 1.1ms; intersectionArea is something like 600us

6/26: added gridded area approximation, for some reason this is super slow? (~3s per call for grid size of 10x10)
ahhhh - Matrix was still used in Triangle::getSignedArea, removing gets double integral down to 800us

6/28: running some more tests: 50 ish triangles on 260x200 image runs in ~1ms per integration call, same number of triangles on 800x464 runs in 4ms per line integral and 7ms per area integral; speed of single integration call is independent of number of triangles, seems to depend on pixel resolution

6/29: apple.jpeg 41 iterations, colorized, 320 triangles
GPU activities:   44.67%  56.2863s     78720  715.02us  583.04us  12.779ms  pixConstantLineInt(Pixel*, int, int, Point*, Point*, Point*, bool, double*)
                  42.92%  54.0837s     53760  1.0060ms  902.91us  2.7252ms  pixConstantDoubleInt(Pixel*, int, int, Triangle*, int, double*, ColorChannel)
                  10.56%  13.3052s     13440  989.97us  911.78us  1.6589ms  pixConstantEnergyInt(Pixel*, int, int, Triangle*, double*, int, double*)
flower.jpg 31 iterations, colorized
GPU activities:   45.02%  29.7278s     39804  746.86us  586.24us  10.350ms  pixConstantLineInt(Pixel*, int, int, Point*, Point*, Point*, bool, double*)
                  42.70%  28.1935s     27392  1.0293ms  868.25us  6.8069ms  pixConstantDoubleInt(Pixel*, int, int, Triangle*, int, double*, ColorChannel)
                  10.48%  6.92015s      6848  1.0105ms  915.04us  1.5629ms  pixConstantEnergyInt(Pixel*, int, int, Triangle*, double*, int, double*)
rose.jpg 12 iterations, 347 triangles
GPU activities:   44.36%  22.6960s     18044  1.2578ms  1.1159ms  3.3495ms  pixConstantDoubleInt(Pixel*, int, int, Triangle*, int, double*, ColorChannel)
                  43.21%  22.1060s     24984  884.81us  747.16us  2.1420ms  pixConstantLineInt(Pixel*, int, int, Point*, Point*, Point*, bool, double*)
                  10.90%  5.57581s      4511  1.2360ms  1.1241ms  1.7361ms  pixConstantEnergyInt(Pixel*, int, int, Triangle*, double*, int, double*)

6/30
sunset.jpg (600x337) 286 triangles, 10 iterations
GPU activities:   50.25%  168.765s     12584  13.411ms  4.0802ms  40.586ms  pixConstantDoubleInt(Pixel*, int, int, Triangle*, int, double*, ColorChannel)
                  34.32%  115.272s     17160  6.7175ms  2.6373ms  30.798ms  pixConstantLineInt(Pixel*, int, int, Point*, Point*, Point*, bool, double*)
                  12.34%  41.4382s      3146  13.172ms  4.5688ms  40.016ms  pixConstantEnergyInt(Pixel*, int, int, Triangle*, double*, int, double*)
panda.jpeg (2000x1125) 202 triangles, 2 iterations
GPU activities:   53.03%  107.515s      2424  44.354ms  43.651ms  112.96ms  pixConstantDoubleInt(Pixel*, int, int, Triangle*, int, double*, ColorChannel)
                  32.94%  66.7960s      2424  27.556ms  27.356ms  38.183ms  pixConstantLineInt(Pixel*, int, int, Point*, Point*, Point*, bool, double*)
                  13.20%  26.7707s       606  44.176ms  43.657ms  50.041ms  pixConstantEnergyInt(Pixel*, int, int, Triangle*, double*, int, double*)
panda.jpeg, 1200 triangles
GPU activities:   45.71%  1.1e+03s     24000  44.447ms  43.600ms  104.49ms  pixConstantDoubleInt(Pixel*, int, int, Triangle*, int, double*, ColorChannel)
                  42.03%  980.787s     35536  27.600ms  27.442ms  40.270ms  pixConstantLineInt(Pixel*, int, int, Point*, Point*, Point*, bool, double*)
                  11.39%  265.916s      6000  44.319ms  43.582ms  50.989ms  pixConstantEnergyInt(Pixel*, int, int, Triangle*, double*, int, double*)
panda.jpeg (cropped to 1251x1124), 1086 triangles, 6 iterations
GPU activities:   48.20%  835.881s     30408  27.489ms  26.845ms  71.128ms  pixConstantDoubleInt(Pixel*, int, int, Triangle*, int, double*, ColorChannel)
                  38.94%  675.410s     39096  17.276ms  16.855ms  29.318ms  pixConstantLineInt(Pixel*, int, int, Point*, Point*, Point*, bool, double*)
                  11.96%  207.493s      7602  27.295ms  26.859ms  31.799ms  pixConstantEnergyInt(Pixel*, int, int, Triangle*, double*, int, double*)
cropped panda, 1239 triangles, 10 iterations
GPU activities:   47.14%  1.5e+03s     54516  27.622ms  27.016ms  65.186ms  pixConstantDoubleInt(Pixel*, int, int, Triangle*, int, double*, ColorChannel)
                  40.21%  1.3e+03s     74340  17.280ms  16.942ms  31.565ms  pixConstantLineInt(Pixel*, int, int, Point*, Point*, Point*, bool, double*)
                  11.76%  375.583s     13629  27.558ms  27.003ms  36.439ms  pixConstantEnergyInt(Pixel*, int, int, Triangle*, double*, int, double*)

7/1:
using apple.jpeg, gridded pixel approximation with a 4x4 grid takes 500us per call but it overestimates the actual value rather significantly (~5%); scales very poorly, 10x10 grid is slower than the exact computation; this is impractical and inaccurate
with boundary point weighting, improves to 5x5 grid taking 550us and only 1% overestimate; with 20x20 can get 0.1% but this is much much slower (~7ms per call); 5x5 does okay on the panda though with half the time of exact area and accurracy within 0.01%
cropped panda, 1239 triangles, 1 iteration, 5x5
GPU activities:   60.27%  360.856s      7434  48.541ms  19.398ms  126.36ms  pixConstantLineInt(Pixel*, int, int, Point*, Point*, Point*, bool, double*)
                  29.33%  175.578s      9912  17.714ms  16.081ms  61.282ms  pixConstantDoubleInt(Pixel*, int, int, Triangle*, int, double*, ColorChannel)
                   7.30%  43.6898s      2478  17.631ms  16.994ms  21.549ms  pixConstantEnergyInt(Pixel*, int, int, Triangle*, double*, int, double*)
cropped panda, 1239 triangles, 1 iteration, 2x2 (surprisingly reasonable approximations)
GPU activities:   81.89%  380.238s      7434  51.149ms  19.405ms  106.21ms  pixConstantLineInt(Pixel*, int, int, Point*, Point*, Point*, bool, double*)
                  10.88%  50.5202s      9912  5.0969ms  3.3213ms  45.848ms  pixConstantDoubleInt(Pixel*, int, int, Triangle*, int, double*, ColorChannel)
                   4.49%  20.8497s     59472  350.58us  7.0720us  5.2720ms  sumBlock(double*, int, double*)
                   2.74%  12.7082s      2478  5.1284ms  4.6496ms  7.4348ms  pixConstantEnergyInt(Pixel*, int, int, Triangle*, double*, int, double*)
2x2 is terrible approximation on apple.jpeg though, causes energy computation to blow up and step size to vanish as colors keep increasing on tiny triangle? what's happening - double integral stays same because approximation is so coarse, but area goes to 0 because area computation is exact
seems 5x5 is decent

7/2:
on the other hand barycentric sampling is consistently under but it is FAST (sampling every 0.5 gives 30us per call on apple with 320 triangles, compared to 1ms for exact)
sampling every 0.05 gives 1% error rate and 160us per call; sampling every 0.02 gives 0.5% error and 900us per call (basically same as exact)
apple.jpeg, 320 triangles, sample every 0.01 is 700us per call and within 1% approximation; sample every 0.05 is 50us per call and 10% approximation; 0.02 is 150us and 2%
panda.jpeg, 1239 triangles: 0.05 is 130us per call and very accurate approximation
